<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Skjaldbaka1">







<title>Verilog课程笔记 | Skjaldbaka1&#39;s blog</title>



    <link rel="icon" href="/favicon.ico">



<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=Roboto+Mono&display=swap');
</style>



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    




    <!-- scripts list from _config.yml -->
    
    <script src="/js/menu.js"></script>
    




    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>







    <script type="text/javascript" async
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        }
      };
    </script>
  <meta name="generator" content="Hexo 7.3.0"></head>
  <body>
    <div class="mask-border"></div>

    <div class="wrapper">
      <div class="header">
  <div class="flex-container">
    <div class="header-inner">
      <div class="site-brand-container">
        <a href="/">
          
            Skjaldbaka1.
          
        </a>
      </div>
      <div id="menu-btn" class="menu-btn" onclick="toggleMenu()">
        Menu
      </div>
      <nav class="site-nav">
        <ul class="menu-list">
          
            
              <li class="menu-item">
                <a href="/">主页</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/archives/">文集</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/categories/gallery/">影集</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/tag/">引索</a>
              </li> 
                   
          
          
            <li class="menu-item search-btn">
              <a href="#">Search</a>
            </li>
          
        </ul>
      </nav>
    </div>
  </div>
</div>


      <div class="main">
        <div class="flex-container">
          <article id="post">

  
    <div class="post-head">
    <div class="post-info">
        <div class="tag-list">
            
                
                    <span class="post-tag">
                        <a href="/tags/%E7%AC%94%E8%AE%B0/">
                            笔记
                        </a>
                    </span>    
                           
            
        </div>
        <div class="post-title">
            
            
                Verilog课程笔记
            
            
        </div>
        <span class="post-date">
            12月 13, 2024
        </span>
    </div>
    <div class="post-img">
        
            <div class="h-line-primary"></div>
              
    </div>
</div>
    <div class="post-content">
    <h3 id="1-1一个基本的Verilog代码构成"><a href="#1-1一个基本的Verilog代码构成" class="headerlink" title="1.1一个基本的Verilog代码构成"></a>1.1一个基本的Verilog代码构成</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module 模块名 ([端口列表]);</span><br><span class="line">[端口信号声明;]</span><br><span class="line">[参数声明；]</span><br></pre></td></tr></table></figure>

<p>如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module full_adder (A,B,CIN,S,COUT);</span><br><span class="line">//端口列表是指电路的输入/输出信号名称列表，信号名由用户指定，各名称间用逗号隔开</span><br><span class="line"> input [3:0] A,B;</span><br><span class="line"> //端口信号声明是要说明端口信号的输入输出属性、信号的数据类型，以及信号的位宽</span><br><span class="line"> //输入输出属性有input,output,inout三种，信号的数据类型常用的有wire,reg两种</span><br><span class="line"> input CIN;</span><br><span class="line"> output reg [3:0] S;</span><br><span class="line"> //[3:0]代表信号的位宽，用[n1:n2]表示;同一类信号之间用逗号隔开</span><br><span class="line"> output COUNT;</span><br></pre></td></tr></table></figure>

<h3 id="1-2语法"><a href="#1-2语法" class="headerlink" title="1.2语法"></a>1.2语法</h3><h4 id="1-逻辑运算关系"><a href="#1-逻辑运算关系" class="headerlink" title="(1)逻辑运算关系"></a>(1)逻辑运算关系</h4><h6 id="算术型"><a href="#算术型" class="headerlink" title="算术型"></a>算术型</h6><table>
<thead>
<tr>
<th>*****</th>
<th><strong>乘法</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>&#x2F;</strong></td>
<td><strong>除法</strong></td>
</tr>
<tr>
<td><strong>+</strong></td>
<td><strong>加法</strong></td>
</tr>
<tr>
<td><strong>-</strong></td>
<td><strong>减法</strong></td>
</tr>
<tr>
<td><strong>%</strong></td>
<td><strong>求余</strong></td>
</tr>
<tr>
<td>******</td>
<td><strong>求幂</strong></td>
</tr>
</tbody></table>
<p>其中运算规则为</p>
<ol>
<li>加减乘除、求幂的操作数可以是实数也可以是整数，求余运算的操作数只能是整数</li>
<li>求余运算结果取第一个操作数的符号</li>
</ol>
<h6 id="逻辑型"><a href="#逻辑型" class="headerlink" title="逻辑型"></a>逻辑型</h6><table>
<thead>
<tr>
<th><strong>！</strong></th>
<th><strong>逻辑非</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>&amp;&amp;</strong></td>
<td><strong>逻辑与</strong></td>
</tr>
<tr>
<td><strong>||</strong></td>
<td><strong>逻辑或</strong></td>
</tr>
</tbody></table>
<p>其中运算规则为</p>
<ol>
<li>逻辑型运算的结果可能是1（逻辑真）、0（逻辑假）、x（不确定）</li>
<li>逻辑运算的操作数可以是任意表达式，表达式的结果被当做逻辑值处理，只有1、0、x三种情况，非0、x即1</li>
</ol>
<h6 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h6><table>
<thead>
<tr>
<th><strong>&gt;</strong></th>
<th><strong>大于</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>&lt;</strong></td>
<td><strong>小于</strong></td>
</tr>
<tr>
<td><strong>&gt;&#x3D;</strong></td>
<td><strong>大于等于</strong></td>
</tr>
<tr>
<td><strong>&lt;&#x3D;</strong></td>
<td><strong>小于等于</strong></td>
</tr>
</tbody></table>
<h6 id="等价运算符"><a href="#等价运算符" class="headerlink" title="等价运算符"></a>等价运算符</h6><table>
<thead>
<tr>
<th><strong>&#x3D;&#x3D;</strong></th>
<th><strong>等于</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>！</strong> <strong>&#x3D;</strong></td>
<td><strong>不等于</strong></td>
</tr>
<tr>
<td><strong>&#x3D;&#x3D;&#x3D;</strong></td>
<td>**case ** <strong>等于</strong></td>
</tr>
<tr>
<td><strong>！</strong> <strong>&#x3D;&#x3D;</strong></td>
<td><strong>case</strong> <strong>不等</strong></td>
</tr>
</tbody></table>
<p>其中运算规则为</p>
<ol>
<li>等于和不等于运算的结果可能是1（逻辑真）、0（逻辑假）、x（不确定）；对于x或a，认为是不确定的值，比较结果为x</li>
<li>case等和case不等的结果只能是1或0，对于x、z认为是确定的值，参加比较</li>
</ol>
<h6 id="按位运算符"><a href="#按位运算符" class="headerlink" title="按位运算符"></a>按位运算符</h6><p>用于二进制数如1001与1111按照一位一位相比较</p>
<table>
<thead>
<tr>
<th><strong>~</strong></th>
<th><strong>按位非</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>&amp;</strong></td>
<td><strong>按位与</strong></td>
</tr>
<tr>
<td><strong>|</strong></td>
<td><strong>按位或</strong></td>
</tr>
<tr>
<td><strong>^</strong></td>
<td><strong>按位异或</strong></td>
</tr>
<tr>
<td><strong>~^</strong> <strong>^~</strong></td>
<td><strong>按位同或</strong></td>
</tr>
</tbody></table>
<p>其中运算规则为</p>
<ol>
<li>其它按位运算的操作数有2个或多个，将两个操作数对应的位两两运算</li>
<li>如果操作数位宽不同，位宽小的会自动左添0补齐</li>
</ol>
<h6 id="缩减运算符"><a href="#缩减运算符" class="headerlink" title="缩减运算符"></a>缩减运算符</h6><p>缩减运算的操作数只有一个，将该数的各位自左至右进行逻辑运算，结果只有一位</p>
<table>
<thead>
<tr>
<th><strong>&amp;</strong></th>
<th><strong>缩减与</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>~&amp;</strong></td>
<td><strong>缩减与非</strong></td>
</tr>
<tr>
<td><strong>|</strong></td>
<td><strong>缩减或</strong></td>
</tr>
<tr>
<td><strong>~|</strong></td>
<td><strong>缩减或非</strong></td>
</tr>
<tr>
<td><strong>^</strong></td>
<td><strong>缩减异或</strong></td>
</tr>
<tr>
<td><strong>~^</strong> <strong>^~</strong></td>
<td><strong>缩减同或</strong></td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">Y=&amp; 4’b1001;</span><br><span class="line">//从左到右，逐位进行与运算，结果为0</span><br><span class="line">Y= ~&amp; 4’b1001; </span><br><span class="line">//跟上面一样，先逐渐进行与运算，得出0后非</span><br></pre></td></tr></table></figure>

<h6 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h6><p>将一位或者多位向左或向右移n位</p>
<table>
<thead>
<tr>
<th><strong>&gt;&gt;</strong></th>
<th><strong>右移</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>&lt;&lt;</strong></td>
<td><strong>左移</strong></td>
</tr>
<tr>
<td><strong>&gt;&gt;&gt;</strong></td>
<td><strong>算术右移</strong></td>
</tr>
<tr>
<td><strong>&lt;&lt;&lt;</strong></td>
<td><strong>算术左移</strong></td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">Y= 4’b1001 &gt;&gt; 1;</span><br><span class="line">// &gt;&gt; 1代表整体向右移动一位，空出来的部分自动补0，故结果为0100</span><br><span class="line">Y= 4’sb1001 &gt;&gt;&gt; 1; </span><br><span class="line">// 算术整体右移一位，原来的最后一位1移动到最左边第一位，变成1100</span><br></pre></td></tr></table></figure>

<h6 id="拼接复制运算符"><a href="#拼接复制运算符" class="headerlink" title="拼接复制运算符"></a>拼接复制运算符</h6><p>可以将两个四位二进制数链接起来</p>
<table>
<thead>
<tr>
<th><strong>{}</strong></th>
<th><strong>拼接</strong></th>
<th>{操作数1, 操作数2, …}</th>
</tr>
</thead>
<tbody><tr>
<td><strong>{ {} }</strong></td>
<td><strong>复制拼接</strong></td>
<td><strong>{n{ 操作数 1, 操作数2, …}}</strong></td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">Y= &#123;4’b1001, 2’b11&#125;;</span><br><span class="line">//将二进制数1001和11拼接起来变成100111</span><br><span class="line">Y= &#123;4&#123;2’b01&#125;&#125;; </span><br><span class="line">//前面的n为多少即复制拼接几次，这里n=4将01复制拼接4次，即01010101</span><br></pre></td></tr></table></figure>

<h6 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h6><p>跟C语言中一样，可以对未知数进行条件赋值</p>
<table>
<thead>
<tr>
<th><strong>表达式</strong>1 ? 表达式<strong>2 :</strong> 表达式<strong>3</strong></th>
<th><strong>用于条件赋值</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>表达式1&#x3D;1</strong></td>
<td><strong>结果等于表达式2</strong></td>
</tr>
<tr>
<td><strong>表达式1&#x3D;0</strong></td>
<td><strong>结果等于表达式3</strong></td>
</tr>
<tr>
<td><strong>表达式1&#x3D;x</strong></td>
<td><strong>结果为x</strong></td>
</tr>
</tbody></table>
<h4 id="2-assign语句"><a href="#2-assign语句" class="headerlink" title="(2)assign语句"></a>(2)assign语句</h4><ul>
<li>assign语句称作连续赋值语句，相当于数电中的电平触发，其总是处于激活状态，只要表达式中的操作数有变化，立即进行计算和赋值（与连续赋值语句对应的另一种语句称为过程赋值语句）</li>
<li>赋值目标必须是<strong>wire</strong>型的，wire表示电路间的连线</li>
</ul>
<p>这里给出一个assign语法的例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">assign y=a;</span><br><span class="line">assign y=a&amp;b;</span><br><span class="line">//基本格式：assign 赋值目标 = 表达式</span><br></pre></td></tr></table></figure>

<h4 id="3-always语句"><a href="#3-always语句" class="headerlink" title="(3)always语句"></a>(3)always语句</h4><ul>
<li>always语句本身不是单一的有意义的一条语句，而是和下面的语句一起构成一个语句块，称之为过程块；过程块中的赋值语句称过程赋值语句</li>
<li>该语句块不是总处于激活状态，当满足激活条件时才能被执行，否则被挂起，挂起时即使操作数有变化，也不执行赋值，赋值目标值保持不变</li>
<li>赋值目标必须是<strong>reg</strong>型的</li>
</ul>
<h5 id="always语法的基本格式和例子"><a href="#always语法的基本格式和例子" class="headerlink" title="always语法的基本格式和例子"></a>always语法的基本格式和例子</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">always @(敏感信号条件表)</span><br><span class="line">//激活条件由敏感信号条件表决定，当敏感条件满足时，过程块被激活</span><br><span class="line">      各类顺序语句；  </span><br><span class="line">例：</span><br><span class="line">always @(posedge CLK)</span><br><span class="line">      Q=D；</span><br></pre></td></tr></table></figure>

<p>敏感条件即上面的<code>@(敏感信号条件表)</code>有两种，一种是边沿敏感，一种是电平敏感</p>
<h6 id="边沿敏感"><a href="#边沿敏感" class="headerlink" title="边沿敏感"></a>边沿敏感</h6><table>
<thead>
<tr>
<th>(posedge 信号名)</th>
<th>信号上升沿到来</th>
<th>例：(posedge clk)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>(negedge 信号名)</strong></td>
<td><strong>信号下降沿到来</strong></td>
<td><strong>例：(negedge clk)</strong></td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">always @ (posedge CLK)</span><br><span class="line">    Q=D；</span><br><span class="line">//当CLK上升沿到来时，激活该语句块，将D的值赋给Q；否则，该语句块挂起，即使D有变化，Q的值也保持不变，直到下一次赋值</span><br><span class="line">//就是数电中上升沿触发的D触发器</span><br></pre></td></tr></table></figure>

<h6 id="电平敏感"><a href="#电平敏感" class="headerlink" title="电平敏感"></a>电平敏感</h6><table>
<thead>
<tr>
<th>(信号名列表)</th>
<th>信号列表中任一信号有变化</th>
</tr>
</thead>
<tbody><tr>
<td><strong>例：(a,b,c)</strong></td>
<td><strong>的a,b,c中有一个信号发生改变，always下的过程块被触发</strong></td>
</tr>
</tbody></table>
<p>其中逗号也可以换成or就变成<code>(a or b or c)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">always @ (D)</span><br><span class="line">    Q=D；</span><br><span class="line">//当D有变化时（不管是由1变0还是由0变1），激活该语句块，将D的值赋给Q；否则，该语句块挂起，Q的值保持不变，直到下一次赋值</span><br><span class="line">//实际是数电中的非门</span><br></pre></td></tr></table></figure>

<h5 id="在always语法中插入if和case等语句"><a href="#在always语法中插入if和case等语句" class="headerlink" title="在always语法中插入if和case等语句"></a>在always语法中插入if和case等语句</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">module DFF2 (CLK,D,Q,RST,EN)</span><br><span class="line">input CLK,D,RST,EN;</span><br><span class="line">//input定义时必须以字母为开头，数字开头不行</span><br><span class="line">output Q;</span><br><span class="line">reg Q;</span><br><span class="line">//定义output若其与always后的代码块有关系，要将其定义为reg类型</span><br><span class="line">always @(posedge CLK or negedge RST)</span><br><span class="line">begin </span><br><span class="line">        if (!RST) Q&lt;=0；</span><br><span class="line">        else if (EN) Q&lt;=D</span><br><span class="line">end</span><br><span class="line">//使用if或者case语句的或者多个语句存在，要在代码块开头和结尾加上begin和end</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>

<p><strong>begin end</strong>之间的赋值语句有阻塞赋值和非阻塞赋值之分</p>
<h6 id="阻塞赋值"><a href="#阻塞赋值" class="headerlink" title="阻塞赋值"></a>阻塞赋值</h6><p>语句顺序执行，前面的执行完才能执行后面，<code>赋值符号：=</code>，<em>右边表达式的计算和对左边寄存器变量的赋值是一个统一的原子操作中的两个动作，这两个动作之间不能再插入其他任何动作</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">赋值目标1=表达式1；</span><br><span class="line">赋值目标2=表达式2；</span><br><span class="line">//赋值语句1会阻塞赋值语句2 ，即只有当赋值语句1执行完才能执行赋值语句2</span><br><span class="line">例:阻塞赋值</span><br><span class="line">begin</span><br><span class="line">    m=a*b;</span><br><span class="line">    y=m;</span><br><span class="line">end</span><br><span class="line">//当m赋值完成后，才能执行y的赋值，y得到的是m的新值</span><br></pre></td></tr></table></figure>

<h6 id="非阻塞赋值"><a href="#非阻塞赋值" class="headerlink" title="非阻塞赋值"></a>非阻塞赋值</h6><p>所有语句并行执行，<code>赋值符号：&lt;=</code>，<em>首先按顺序计算右边表达式的值，但是并不马上赋值，而是要等到过程结束时再按顺序赋值。</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">赋值目标1&lt;=表达式1；</span><br><span class="line">赋值目标2&lt;=表达式2；</span><br><span class="line">//赋值语句1不会阻塞赋值语句2 ，赋值语句1和赋值语句2并行执行</span><br><span class="line">例：非阻塞赋值</span><br><span class="line">begin</span><br><span class="line">    m&lt;=a*b;</span><br><span class="line">    y&lt;=m;</span><br><span class="line">end</span><br><span class="line">//m和y的赋值并行执行，y得到的是m的旧值</span><br></pre></td></tr></table></figure>

<h4 id="底层模块和门语言调用"><a href="#底层模块和门语言调用" class="headerlink" title="底层模块和门语言调用"></a>底层模块和门语言调用</h4><h5 id="底层模块调用"><a href="#底层模块调用" class="headerlink" title="底层模块调用"></a>底层模块调用</h5><p>为了实现多个门电路组合使用，我们先设计一个底层的基础的D触发器模块</p>
<p>其用代码表示为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module DFF(CLK,D,Q)</span><br><span class="line">    output reg Q;</span><br><span class="line">    input CLK,D;</span><br><span class="line">always @ (posedge CLK)</span><br><span class="line">    Q&lt;=D;</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>

<p>这时我们再将两个模块组合起来，加入两个内部变量d1和q1调用底层模块，在调用底层模块的时候要遵顼这两个格式</p>
<ul>
<li><p><strong>端口名关联法（命名法）</strong><br>因为有名字对应，不必按底层模块的端口信号列表顺序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(.底层端口名1(外接信号名1),.底层端口名2(外接信号名2),…)</span><br><span class="line">DFF dff1(.CLK(clk),.D(d1),.Q(q1));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>位置关联法（顺序法）</strong><br>必须严格按照底层模块的端口信号列表顺序书写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(外接信号名1,外接信号名2,…)</span><br><span class="line">DFF dff2(q1,d,q);</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module examp (clk,d,a,q)</span><br><span class="line">    output  q;</span><br><span class="line">    input clk,d,a;</span><br><span class="line"></span><br><span class="line">    wire d1;</span><br><span class="line">    wire q1;</span><br><span class="line"></span><br><span class="line">DFF dff1(.CLK(clk),.D(d1),.Q(q1));</span><br><span class="line">DFF dff2(q1,d,q);</span><br><span class="line"></span><br><span class="line">or (d1,a,q);</span><br><span class="line">//门原语或门</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>

<h5 id="门原语调用"><a href="#门原语调用" class="headerlink" title="门原语调用"></a>门原语调用</h5><p>Verilog语言提供已经设计好的门，称为门原语（primitive，共12个），这些门可直接调用，不用再对其进行功能描述</p>
<p>门原语调用格式：<code>门原语名 实例名 (端口连接)</code></p>
<p><strong>其中实例名可省略（和模块调用不同），端口连接只能采用顺序法，输出在前，输入在后。</strong></p>
<p>于是实际情况：<code>例：and (out, in1, in2);</code></p>
<p>端口连接中第一个是输出，其余是输入，输入个数不限</p>
<p>下面给出6个与门相关的门原语</p>
<table>
<thead>
<tr>
<th><strong>and （与）</strong></th>
<th><strong>or（或）</strong></th>
<th><strong>xor（异或）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>nand（与非）</strong></td>
<td><strong>nor（或非）</strong></td>
<td><strong>xnor（同或）</strong></td>
</tr>
</tbody></table>
<ul>
<li>特殊门</li>
</ul>
<table>
<thead>
<tr>
<th>not （非门）</th>
<th><strong>not (OUT1, IN);</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>buf（缓冲器）</strong></td>
<td><strong>buf b1_2out(OUT1, OUT2, IN);</strong></td>
</tr>
</tbody></table>
<h5 id="三态门"><a href="#三态门" class="headerlink" title="三态门"></a>三态门</h5><table>
<thead>
<tr>
<th><strong>bufif1(控制端1有效缓冲器)</strong></th>
<th><strong>bufif1 b1 (out, in, ctrl);</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>bufif0(控制端0有效缓冲器)</strong></td>
<td><strong>如上修改名称</strong></td>
</tr>
<tr>
<td><strong>notif1(控制端1有效非门）</strong></td>
<td><strong>notif1 n1 (out, in, ctrl);</strong></td>
</tr>
<tr>
<td><strong>notif0(控制端0有效非门）</strong></td>
<td><strong>如上修改名称</strong></td>
</tr>
</tbody></table>
<p>端口列表中前面是输出，中间是输入，最后是使能端，输出个数不限。</p>
<h4 id="数字表示格式"><a href="#数字表示格式" class="headerlink" title="数字表示格式"></a>数字表示格式</h4><p>无符号数的表示方法：<code>&lt;位宽&gt;’ &lt;进制&gt;&lt;数字&gt;</code></p>

</div> 

<script>
    window.onload = detectors();
</script>
    <div class="post-footer">
    <div class="h-line-primary"></div>
    <nav class="post-nav">
        <div class="prev-item">
           
                <div class="icon arrow-left"></div>
                <div class="post-link">
                    <a href="/2024/12/13/%E7%AC%94%E8%AE%B0%E9%9B%86%E6%88%90%E7%89%88%E5%9B%BE%E5%AE%9E%E9%AA%8C%E8%AF%BE/">Prev</a>
                </div>
            
        </div>
        <div class="next-item">
            
                <div class="icon arrow-right"></div>
                <div class="post-link">
                  <a href="/2024/12/11/%E7%AC%94%E8%AE%B0%E5%8D%8A%E7%89%A90%E5%9B%BA%E4%BD%93%E7%89%A9%E7%90%86%E5%AF%BC%E5%85%A5/">Next</a>  
                </div>  
            
        </div>
    </nav>
</div>

    
      <div class="post-comment">

     

     
    
    

</div>
     
  
</article>
        </div>
      </div>
      
      <div class="footer">
    <div class="flex-container">
        <div class="footer-text">
            
            
                Skjaldbaka1© | 
            
            
                Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/zoeingwingkei/frame/">Frame</a>
                
        </div>
    </div>
</div>
    </div>
  </body>
</html>

